name: Deploy CDK (Experimental)

on:
  push:
    branches:
      - 'mt-cdk-oidc'
  workflow_dispatch:

permissions:
  id-token: write
  contents: read
  deployments: write

jobs:
  begin-deployment:
    name: Begin CDK Deployment
    runs-on: ubuntu-24.04
    environment:
      name: dev
    permissions:
      deployments: write
    outputs:
      deploy-id: ${{ steps.ghdeployment.outputs.deployment_id }}
      stage-name: ${{ steps.stage-name.outputs.stage-name-for-branch}}
      app-version: ${{ steps.branch-name.outputs.app-version}}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 40

      - name: Check for secrets
        uses: ./.github/actions/check_secrets
        with:
          expected-secret: ${{ secrets.VITE_APP_AUTH_MODE }}

      - name: set app version
        id: app-version
        shell: bash
        run: echo "app-version=$(scripts/app_version.sh)" >> "$GITHUB_OUTPUT"

      - name: set stage name
        id: stage-name
        shell: bash
        run: |
          echo "stage-name-for-branch=$(./scripts/stage_name_for_branch.sh ${GITHUB_REF#refs/heads/})" >> "$GITHUB_OUTPUT"

      - name: set branch name
        id: branch-name
        shell: bash
        run: echo "branch-name=$(echo ${GITHUB_REF#refs/heads/})" >> "$GITHUB_OUTPUT"

      - name: lock this branch to prevent concurrent deploys
        run: ./.github/github-lock.sh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup env
        uses: ./.github/actions/setup_env

      - name: build scripts
        shell: bash
        run: pnpm -r build:ci-scripts

      - uses: chrnorm/deployment-action@v2
        name: Create GitHub deployment
        id: ghdeployment
        with:
          token: '${{ github.token }}'
          environment: review-apps-cdk
          transient-environment: true
          description: CDK stack ${{ steps.stage-name.outputs.stage-name-for-branch}}
          initial-status: in_progress

  deploy-github-oidc:
    needs: [begin-deployment]
    name: deploy - GitHub OIDC service
    runs-on: ubuntu-24.04
    environment:
      name: dev
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Setup env
        uses: ./.github/actions/setup_env

      - name: Generate Code
        run: pnpm -r generate

      - name: Build packages
        shell: bash
        run: pnpm build:packages

      - name: Get AWS credentials (bootstrap with main OIDC role)
        uses: ./.github/actions/get_aws_credentials
        with:
          region: ${{ vars.AWS_DEFAULT_REGION }}
          account-id: ${{ secrets.DEV_AWS_ACCOUNT_ID }}
          # Use main OIDC role for bootstrapping since branch-specific role doesn't exist yet
          stage-name: main
          changed-services: 'github-oidc'

      - name: deploy github-oidc with CDK
        id: deploy-github-oidc-cdk
        working-directory: services/infra-cdk
        env:
          STAGE_NAME: ${{ needs.begin-deployment.outputs.stage-name }}
        run: |
          echo "Starting CDK OIDC deployment for stage: ${STAGE_NAME}"
          echo "Stack name will be: MCR-GitHubOIDC-${STAGE_NAME}"

          # List current stacks to see what exists
          #echo "=== Current CDK stacks ==="
          #pnpm cdk list --context stage=${STAGE_NAME} || echo "No CDK stacks found"

          # Deploy the OIDC stack (CDK will compile TypeScript automatically)
          echo "=== Deploying OIDC stack ==="
          pnpm cdk deploy MCR-GitHubOIDC-${STAGE_NAME} --context stage=${STAGE_NAME} --require-approval never

          echo "=== CDK deployment completed ==="

  web-unit-tests:
    name: test - web unit tests
    runs-on: ubuntu-24.04
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Setup env
        uses: ./.github/actions/setup_env

      - name: Generate Code
        run: pnpm -r generate

      - name: Build packages
        shell: bash
        run: pnpm build:packages

      - name: Web Unit Tests
        id: web-unit-tests
        env:
          NODE_OPTIONS: --max_old_space_size=6000
          VITE_APP_AUTH_MODE: AWS_COGNITO
          DATABASE_URL: postgresql://postgres:shhhsecret@localhost:5432/postgres?schema=public&connection_limit=5 #pragma: allowlist secret
        working-directory: services/app-web
        run: |
          set -e
          pnpm test:coverage
          exit $?

      - name: upload app web gen directory
        uses: actions/upload-artifact@v4
        with:
          name: app-web-gen
          path: ./services/app-web/src/gen

      - name: upload cypress gen directory
        uses: actions/upload-artifact@v4
        with:
          name: cypress-gen
          path: ./services/cypress/gen

      - name: upload unit test coverage
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-coverage
          path: ./services/app-web/coverage/coverage-final.json

  api-unit-tests:
    name: test - api unit tests
    runs-on: ubuntu-24.04
    services:
      postgres:
        image: postgres:13.3
        env:
          VITE_APP_AUTH_MODE: AWS_COGNITO
          POSTGRES_PASSWORD: shhhsecret #pragma: allowlist secret
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Setup env
        uses: ./.github/actions/setup_env

      - name: Generate code
        run: pnpm -r generate

      - name: Generate Prisma
        env:
          NODE_OPTIONS: --max_old_space_size=6000
          VITE_APP_AUTH_MODE: AWS_COGNITO
          DATABASE_URL: postgresql://postgres:shhhsecret@localhost:5432/postgres?schema=public&connection_limit=5 #pragma: allowlist secret
        working-directory: services/app-api
        run: |
          pnpm generate
          npx prisma migrate reset --force

      - name: Build packages
        shell: bash
        run: pnpm build:packages

      - name: API Unit Tests
        id: api-unit-tests
        env:
          NODE_OPTIONS: --max_old_space_size=6000
          VITE_APP_OTEL_COLLECTOR_URL: ${{vars.VITE_APP_OTEL_COLLECTOR_URL}}
          VITE_APP_AUTH_MODE: AWS_COGNITO
          DATABASE_URL: postgresql://postgres:shhhsecret@localhost:5432/postgres?schema=public&connection_limit=5 #pragma: allowlist secret
        working-directory: services/app-api
        run: |
          set -e
          pnpm test:coverage
          exit $?

      - name: upload api test coverage
        uses: actions/upload-artifact@v4
        with:
          name: api-test-coverage
          path: ./services/app-api/coverage/coverage-final.json

  build-lambda-layers:
    name: build - lambda layers
    runs-on: ubuntu-24.04
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Setup env
        uses: ./.github/actions/setup_env

      - name: Generate protos
        working-directory: services/app-proto
        run: pnpm generate

      # Generate Prisma Client and binary that can run in a lambda environment
      - name: Prepare prisma client
        working-directory: services/app-api
        env:
          PRISMA_CLI_BINARY_TARGETS: rhel-openssl-3.0.x
        run: pnpm prisma generate

      - name: Prepare "@prisma/client" lambda layer
        working-directory: services/app-api
        run: ./scripts/prepare-prisma-layer.sh

      - uses: actions/upload-artifact@v4
        with:
          name: lambda-layers-prisma-client-migration
          path: ./services/app-api/lambda-layers-prisma-client-migration

      - uses: actions/upload-artifact@v4
        with:
          name: lambda-layers-prisma-client-engine
          path: ./services/app-api/lambda-layers-prisma-client-engine

      - name: Prepare postgres tools lambda layer
        working-directory: services/postgres
        run: ./build-postgres-lambda-layer.sh

      - uses: actions/upload-artifact@v4
        with:
          name: lambda-layers-postgres-tools
          path: ./services/postgres/lambda-layers-postgres-tools

  build-clamav-layer:
    name: build - clamav layer
    runs-on: ubuntu-24.04
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'

      - name: Prepare ClamAV layer
        working-directory: services/uploads/src/avLayer
        run: ./dockerbuild.sh

      - uses: actions/upload-artifact@v4
        with:
          name: lambda-layers-clamav
          path: ./services/uploads/src/avLayer/build/lambda_layer.zip

  deploy-cdk-foundation:
    needs: [begin-deployment, deploy-github-oidc, build-clamav-layer]
    name: deploy - CDK foundation stacks
    runs-on: ubuntu-24.04
    environment: dev
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Setup env
        uses: ./.github/actions/setup_env

      - name: Generate Code
        run: pnpm -r generate

      - name: Build packages
        shell: bash
        run: pnpm build:packages

      - name: Get AWS credentials
        uses: ./.github/actions/get_aws_credentials
        with:
          region: ${{ vars.AWS_DEFAULT_REGION }}
          account-id: ${{ secrets.DEV_AWS_ACCOUNT_ID }}
          stage-name: ${{ needs.begin-deployment.outputs.stage-name }}

      - name: Deploy CDK foundation stacks
        working-directory: services/infra-cdk
        env:
          STAGE_NAME: ${{ needs.begin-deployment.outputs.stage-name }}
        run: |
          # Create basic .env file for CDK
          cat > .env.dev << EOF
          # Basic CDK environment configuration  
          AWS_REGION=${{ vars.AWS_DEFAULT_REGION }}
          NR_LICENSE_KEY=${{ secrets.NR_LICENSE_KEY }}
          IAM_PERMISSIONS_BOUNDARY=${{ secrets.DEV_IAM_PERMISSIONS_BOUNDARY }}
          IAM_PATH=${{ secrets.IAM_PATH }}
          EOF

          ./scripts/deploy-foundation.sh $STAGE_NAME

  deploy-cdk-layers:
    needs: [begin-deployment, deploy-cdk-foundation, build-lambda-layers]
    name: deploy - CDK Lambda layers
    runs-on: ubuntu-24.04
    environment: dev
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Setup env
        uses: ./.github/actions/setup_env

      - name: Get AWS credentials
        uses: ./.github/actions/get_aws_credentials
        with:
          region: ${{ vars.AWS_DEFAULT_REGION }}
          account-id: ${{ secrets.DEV_AWS_ACCOUNT_ID }}
          stage-name: ${{ needs.begin-deployment.outputs.stage-name }}

      - name: Download Prisma layers
        uses: actions/download-artifact@v4
        with:
          name: lambda-layers-prisma-client-migration
          path: ./services/infra-cdk/lambda-layers-prisma-client-migration

      - name: Download Prisma engine layers
        uses: actions/download-artifact@v4
        with:
          name: lambda-layers-prisma-client-engine
          path: ./services/infra-cdk/lambda-layers-prisma-client-engine

      - name: Download Postgres tools layers
        uses: actions/download-artifact@v4
        with:
          name: lambda-layers-postgres-tools
          path: ./services/infra-cdk/lambda-layers-postgres-tools

      - name: Deploy CDK Lambda layers
        working-directory: services/infra-cdk
        env:
          STAGE_NAME: ${{ needs.begin-deployment.outputs.stage-name }}
        run: ./scripts/deploy-layers.sh $STAGE_NAME

  deploy-cdk-app:
    needs: [begin-deployment, deploy-cdk-layers, web-unit-tests, api-unit-tests]
    if: |
      always() &&
      (needs.deploy-cdk-layers.result == 'success') &&
      needs.web-unit-tests.result == 'success' &&
      needs.api-unit-tests.result == 'success' &&
      needs.begin-deployment.result == 'success'
    name: deploy - CDK application stacks
    runs-on: ubuntu-24.04
    environment: dev
    outputs:
      application-endpoint: ${{ steps.save-app-endpoint.outputs.app-endpoint }}
      api-endpoint: ${{ steps.save-api-endpoint.outputs.api-endpoint }}
      cognito-user-pool-id: ${{ steps.save-cognito-user-pool-id.outputs.value }}
      cognito-region: ${{ steps.save-cognito-region.outputs.value }}
      cognito-identity-pool-id: ${{ steps.save-cognito-identity-pool-id.outputs.value }}
      cognito-user-pool-web-client-id: ${{ steps.save-cognito-user-pool-web-client-id.outputs.value }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Setup env
        uses: ./.github/actions/setup_env

      - name: Get AWS credentials
        uses: ./.github/actions/get_aws_credentials
        with:
          region: ${{ vars.AWS_DEFAULT_REGION }}
          account-id: ${{ secrets.DEV_AWS_ACCOUNT_ID }}
          stage-name: ${{ needs.begin-deployment.outputs.stage-name }}

      - name: Deploy CDK compute stacks
        working-directory: services/infra-cdk
        env:
          STAGE_NAME: ${{ needs.begin-deployment.outputs.stage-name }}
        run: ./scripts/deploy-compute.sh $STAGE_NAME

      - name: Deploy CDK frontend stacks
        working-directory: services/infra-cdk
        env:
          STAGE_NAME: ${{ needs.begin-deployment.outputs.stage-name }}
        run: ./scripts/deploy-frontend.sh $STAGE_NAME

      - name: Create Test Users
        env:
          STAGE_NAME: ${{ needs.begin-deployment.outputs.stage-name }}
          TEST_USERS_PASS: ${{ secrets.TEST_USERS_PASS }}
        run: |
          cd scripts
          pnpm tsc
          node ./add_cypress_test_users.js $STAGE_NAME $TEST_USERS_PASS

      - name: Run migrate to turn on Aurora
        id: run-migrations
        working-directory: services/app-api
        env:
          STAGE_NAME: ${{ needs.begin-deployment.outputs.stage-name }}
        run: |
          ./scripts/invoke-migrate-lambda.sh app-api-$STAGE_NAME-migrate

      # TODO: These output commands need to be adapted for CDK stack outputs
      # For now, we'll use placeholder values to get the workflow working
      - name: get application endpoint
        id: save-app-endpoint
        env:
          STAGE_NAME: ${{ needs.begin-deployment.outputs.stage-name }}
        run: |
          # TODO: Extract from CDK outputs
          endpoint="https://$STAGE_NAME.mcr.cms.gov"
          echo "app-endpoint=$endpoint" >> "$GITHUB_OUTPUT"

      - name: get api endpoint
        id: save-api-endpoint
        env:
          STAGE_NAME: ${{ needs.begin-deployment.outputs.stage-name }}
        run: |
          # TODO: Extract from CDK outputs
          endpoint="https://api-$STAGE_NAME.mcr.cms.gov"
          echo "api-endpoint=$endpoint" >> "$GITHUB_OUTPUT"

      - name: get cognito user pool id
        id: save-cognito-user-pool-id
        env:
          STAGE_NAME: ${{ needs.begin-deployment.outputs.stage-name }}
        run: |
          # TODO: Extract from CDK outputs
          echo "value=us-east-1_placeholder" >> "$GITHUB_OUTPUT"

      - name: get cognito region
        id: save-cognito-region
        env:
          STAGE_NAME: ${{ needs.begin-deployment.outputs.stage-name }}
        run: |
          echo "value=us-east-1" >> "$GITHUB_OUTPUT"

      - name: get cognito identity pool id
        id: save-cognito-identity-pool-id
        env:
          STAGE_NAME: ${{ needs.begin-deployment.outputs.stage-name }}
        run: |
          # TODO: Extract from CDK outputs
          echo "value=us-east-1:placeholder" >> "$GITHUB_OUTPUT"

      - name: get cognito user pool web client id
        id: save-cognito-user-pool-web-client-id
        env:
          STAGE_NAME: ${{ needs.begin-deployment.outputs.stage-name }}
        run: |
          # TODO: Extract from CDK outputs
          echo "value=placeholder" >> "$GITHUB_OUTPUT"

  end-deployment:
    needs: [begin-deployment, deploy-cdk-app]
    if: always() && needs.begin-deployment.result == 'success'
    name: End CDK Deployment
    runs-on: ubuntu-24.04
    permissions:
      deployments: write
    steps:
      - uses: actions/checkout@v4

      - name: Update deployment status (failure)
        if: failure() && needs.begin-deployment.result == 'success'
        uses: chrnorm/deployment-status@v2
        with:
          token: '${{ github.token }}'
          state: 'failure'
          deployment_id: ${{ needs.begin-deployment.outputs.deploy-id }}

      - name: Update deployment status (success)
        if: needs.deploy-cdk-app.result == 'success'
        uses: chrnorm/deployment-status@v2
        with:
          token: '${{ github.token }}'
          environment-url: ${{ needs.deploy-cdk-app.outputs.application-endpoint }}
          state: 'success'
          deployment-id: ${{ needs.begin-deployment.outputs.deploy-id }}

      - name: Clean up review deployments
        uses: ./.github/actions/clean_up_deployments
        with:
          environment: review-apps-cdk

  # TODO: Add Cypress tests once endpoints are properly extracted
  # cypress:
  #   name: cypress-cdk-run
  #   timeout-minutes: 25
  #   needs: [begin-deployment, deploy-cdk-app]
  #   environment: dev
  #   if: always() && needs.deploy-cdk-app.result == 'success'
  #   # ... (similar to original cypress job but using CDK outputs)
