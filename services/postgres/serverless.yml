service: postgres

frameworkVersion: '4.2.3'

plugins:
  - serverless-stack-termination-protection
  - serverless-s3-bucket-helper
  - serverless-iam-helper
  - serverless-scriptable-plugin

provider:
  name: aws
  runtime: python3.11
  region: us-east-1
  iam:
    role:
      path: ${self:custom.iamPath}
      permissionsBoundary: ${self:custom.iamPermissionsBoundary}
      statements:
        - Effect: 'Allow'
          Action:
            - secretsmanager:DescribeSecret # pragma: allowlist secret
            - secretsmanager:GetSecretValue # pragma: allowlist secret
            - secretsmanager:PutSecretValue # pragma: allowlist secret
            - secretsmanager:UpdateSecretVersionStage # pragma: allowlist secret
          Resource: '*'
          Condition:
            StringEquals:
              'secretsmanager:resource/AllowRotationLambdaArn': '${self:custom.rotatorArn}' # pragma: allowlist secret
        - Effect: Allow
          Action:
            - secretsmanager:GetRandomPassword # pragma: allowlist secret
          Resource: '*'
        - Effect: Allow
          Action:
            - ec2:CreateNetworkInterface
            - ec2:DeleteNetworkInterface
            - ec2:DescribeNetworkInterfaces
          Resource: '*'

custom:
  stage: ${opt:stage, self:provider.stage}
  databaseName: !Sub aurora_${self:service}_${sls:stage}_${AWS::AccountId}
  vpcId: ${env:VPC_ID}
  sgId: ${env:SG_ID}
  privateSubnets:
    - ${env:SUBNET_PRIVATE_A_ID}
    - ${env:SUBNET_PRIVATE_B_ID}
    - ${env:SUBNET_PRIVATE_C_ID}
  publicSubnetA: ${env:SUBNET_PUBLIC_A_ID}
  iamPermissionsBoundary: ${env:IAM_PERMISSIONS_BOUNDARY}
  iamPath: ${env:IAM_PATH}
  rotatorArn: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${self:service}-${sls:stage}-rotator'
  slackWebhookUrl: ${env:SLACK_WEBHOOK}
  serverlessTerminationProtection:
    stages:
      - dev
      - val
      - prod
      - main
  pauseAurora:
    other: true
    val: false
    prod: false
  deletionPolicy:
    other: 'Delete'
    val: 'Retain'
    prod: 'Retain'
  auroraMinCapacity:
    other: 0.5
    val: 1
    prod: 1
  scriptable:
    hooks:
      before:package:createDeploymentArtifacts: pnpm build
      before:deploy:finalize: node scripts/uploadScripts.js ${self:custom.stage}

package:
  individually: true

functions:
  rotator:
    runtime: python3.11
    handler: lambda_function.lambda_handler
    description: Conducts an AWS SecretsManager secret rotation for RDS PostgreSQL using single user rotation scheme
    timeout: 30
    vpc:
      securityGroupIds: ${self:custom.sgId}
      subnetIds: ${self:custom.privateSubnets}
    environment:
      SECRETS_MANAGER_ENDPOINT: !Sub 'https://secretsmanager.${AWS::Region}.amazonaws.com'
    package:
      artifact: s3://secrets-manager-rotation-apps-c0de1e0412b469545054417cc38af3c3/SecretsManagerRDSPostgreSQLRotationSingleUser/SecretsManagerRDSPostgreSQLRotationSingleUser.zip

resources:
  Conditions:
    IsDevValProd: !Or
      - !Equals ['${sls:stage}', 'main']
      - !Equals ['${sls:stage}', 'val']
      - !Equals ['${sls:stage}', 'prod']

  Resources:
    # VPC endpoint for rotation lambda
    SecretsManagerVPCEndpoint:
      Type: AWS::EC2::VPCEndpoint
      Properties:
        SubnetIds: '${self:custom.privateSubnets}'
        SecurityGroupIds: ['${self:custom.sgId}']
        VpcEndpointType: Interface
        ServiceName:
          Fn::Sub: com.amazonaws.${AWS::Region}.secretsmanager
        VpcId: ${self:custom.vpcId}

    PostgresSecret:
      Type: AWS::SecretsManager::Secret
      Properties:
        Name: 'aurora_${self:service}_${sls:stage}'
        Description: 'Dynamically generated password for aurora serverless postgres'
        GenerateSecretString:
          SecretStringTemplate: '{"username": "mcreviewadmin"}'
          GenerateStringKey: password
          PasswordLength: 30
          ExcludePunctuation: true

    PostgresAuroraV2:
      Type: AWS::RDS::DBCluster
      DeletionPolicy: ${self:custom.deletionPolicy.${opt:stage}, self:custom.deletionPolicy.other}
      Properties:
        Engine: aurora-postgresql
        DatabaseName: '${self:custom.databaseName}'
        MasterUsername: !Sub '{{resolve:secretsmanager:${PostgresSecret}::username}}'
        MasterUserPassword: !Sub '{{resolve:secretsmanager:${PostgresSecret}::password}}'
        DBSubnetGroupName: !Ref PostgresSubnetGroup
        VpcSecurityGroupIds: ['${self:custom.sgId}']
        CopyTagsToSnapshot: true
        BackupRetentionPeriod: 7
        EnableCloudwatchLogsExports:
          - postgresql
        ServerlessV2ScalingConfiguration:
          MinCapacity: ${self:custom.auroraMinCapacity.${opt:stage}, self:custom.auroraMinCapacity.other}
          MaxCapacity: 16

    PostgresAuroraV2Instance:
      Type: AWS::RDS::DBInstance
      DeletionPolicy: ${self:custom.deletionPolicy.${opt:stage}, self:custom.deletionPolicy.other}
      Properties:
        Engine: aurora-postgresql
        DBInstanceClass: db.serverless
        DBClusterIdentifier: !Ref PostgresAuroraV2
        AutoMinorVersionUpgrade: true

    PostgresVMScriptsBucket:
      Type: 'AWS::S3::Bucket'
      Condition: IsDevValProd
      Properties:
        BucketName: !Sub ${self:service}-${sls:stage}-postgres-infra-scripts
        AccessControl: Private
        PublicAccessBlockConfiguration:
          BlockPublicAcls: true
          BlockPublicPolicy: true
          IgnorePublicAcls: true
          RestrictPublicBuckets: true
        BucketEncryption:
          ServerSideEncryptionConfiguration:
            - ServerSideEncryptionByDefault:
                SSEAlgorithm: AES256

    PostgresVMScriptsBucketPolicy:
      Type: AWS::S3::BucketPolicy
      Condition: IsDevValProd
      Properties:
        Bucket: !Ref PostgresVMScriptsBucket
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Sid: ForceSSLOnlyAccess
              Effect: Deny
              Principal: '*'
              Action: 's3:*'
              Resource:
                - !Sub arn:aws:s3:::${self:service}-${sls:stage}-postgres-infra-scripts
                - !Sub arn:aws:s3:::${self:service}-${sls:stage}-postgres-infra-scripts/*
              Condition:
                Bool:
                  aws:SecureTransport: false

    PostgresVM:
      Type: 'AWS::EC2::Instance'
      Condition: IsDevValProd
      DependsOn:
        - PostgresVMScriptsBucket
        - PostgresAuroraV2
      Properties:
        InstanceType: t2.micro
        ImageId: ami-05bfc1ab11bfbf484
        IamInstanceProfile: !Ref PgVMIAMInstanceProfile
        Tags:
          - Key: mcr-vmuse
            Value: jumpbox
        NetworkInterfaces:
          - AssociatePublicIpAddress: true
            DeviceIndex: '0'
            GroupSet:
              - !Ref PostgresVmSg
              - ${self:custom.sgId}
            SubnetId: !Sub ${self:custom.publicSubnetA}
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash
            # get apt data for postgres-14
            sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
            wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -

            apt update && apt install unzip postgresql-14 postgresql-contrib -y
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip" && unzip awscliv2.zip
            ./aws/install

            # We need to make sure we download the vm scripts. There can be a lag between when 
            # serverless uploads the scripts and the launch of the instance.
            copy_files_from_s3() {
              aws s3 cp s3://${PostgresVMScriptsBucket}/files/vm-startup.sh /usr/local/bin/vm-startup.sh
              aws s3 cp s3://${PostgresVMScriptsBucket}/files/vm-shutdown.sh /usr/local/bin/vm-shutdown.sh
              aws s3 cp s3://${PostgresVMScriptsBucket}/files/slack-notify.service /etc/systemd/system/notify-slack.service
              aws s3 cp s3://${PostgresVMScriptsBucket}/files/authorized_keys /home/ubuntu/.ssh/authorized_keys
            }

            download_failures=0
            while true; do
              copy_files_from_s3
              exit_code=$?

              if [ $exit_code -eq 0 ]; then
                echo "Downloaded vm scripts from s3 successfully"
                break
              else
                echo "Failed to download vm scripts from s3. Retrying in 10 seconds..."
                download_failures=$((download_failures+1))

                if [ $download_failures -eq 60 ]; then
                  echo "Maximum attempts of aws s3 cp reached. Exiting..."
                  break
                fi

                sleep 10
              fi
            done

            chmod +x /usr/local/bin/vm-startup.sh
            chmod +x /usr/local/bin/vm-shutdown.sh
            chmod +x /etc/systemd/system/notify-slack.service

            chmod 600 /home/ubuntu/.ssh/authorized_keys
            chown ubuntu:ubuntu /home/ubuntu/.ssh/authorized_keys

            sed -i "s,SLACK_WEBHOOK,${self:custom.slackWebhookUrl},g" /usr/local/bin/vm-startup.sh
            sed -i "s,SLACK_WEBHOOK,${self:custom.slackWebhookUrl},g" /usr/local/bin/vm-shutdown.sh
            sed -i "s,STAGE,${self:custom.stage},g" /usr/local/bin/vm-startup.sh 
            sed -i "s,STAGE,${self:custom.stage},g" /usr/local/bin/vm-shutdown.sh
            systemctl start notify-slack
            systemctl enable notify-slack

    PgVMIAMRole:
      Type: AWS::IAM::Role
      Condition: IsDevValProd
      Properties:
        Path: '/delegatedadmin/developer/'
        PermissionsBoundary: !Sub 'arn:aws:iam::${AWS::AccountId}:policy/cms-cloud-admin/ct-ado-poweruser-permissions-boundary-policy'
        RoleName: !Sub 'postgresvm-${sls:stage}-ServiceRole'
        AssumeRolePolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Principal:
                Service: ec2.amazonaws.com
              Action: sts:AssumeRole
        Policies:
          - PolicyName: 's3Access'
            PolicyDocument:
              Version: '2012-10-17'
              Statement:
                - Effect: 'Allow'
                  Action:
                    - 's3:*'
                  Resource:
                    - !GetAtt PostgresVMScriptsBucket.Arn
                    - !Join ['', [!GetAtt PostgresVMScriptsBucket.Arn, '/*']]

    PgVMIAMInstanceProfile:
      Type: AWS::IAM::InstanceProfile
      Condition: IsDevValProd
      Properties:
        Path: '/delegatedadmin/developer/'
        Roles:
          - !Ref PgVMIAMRole

    PostgresVmSg:
      Type: 'AWS::EC2::SecurityGroup'
      Condition: IsDevValProd
      Properties:
        GroupDescription: Enable SSH access via port 22
        VpcId: !Sub ${self:custom.vpcId}
        SecurityGroupIngress:
          - IpProtocol: tcp
            FromPort: 22
            ToPort: 22
            CidrIp: 34.196.35.156/32
          - IpProtocol: tcp
            FromPort: 22
            ToPort: 22
            CidrIp: 73.170.112.247/32
          - IpProtocol: tcp
            FromPort: 22
            ToPort: 22
            CidrIp: 172.58.0.0/16
          - IpProtocol: tcp
            FromPort: 22
            ToPort: 22
            CidrIp: 162.218.226.179/32
          - IpProtocol: tcp
            FromPort: 22
            ToPort: 22
            CidrIp: 66.108.108.206/32
          - IpProtocol: tcp
            FromPort: 22
            ToPort: 22
            CidrIp: 207.153.23.192/32
          - IpProtocol: tcp
            FromPort: 22
            ToPort: 22
            CidrIpv6: 2601:483:5300:22cf:e1a1:88e9:46b7:2c49/128

    PostgresSubnetGroup:
      Type: AWS::RDS::DBSubnetGroup
      Properties:
        DBSubnetGroupDescription: postgres aurora serverless
        SubnetIds: '${self:custom.privateSubnets}'

    SecretsRDSAttachment:
      Type: AWS::SecretsManager::SecretTargetAttachment
      Properties:
        SecretId: !Ref PostgresSecret
        TargetId: !Sub 'arn:aws:rds:${AWS::Region}:${AWS::AccountId}:cluster:${PostgresAuroraV2}'
        TargetType: AWS::RDS::DBCluster

    PostgresSecretsRotationSchedule:
      Type: AWS::SecretsManager::RotationSchedule
      DependsOn:
        - PostgresAuroraV2
        - SecretsRDSAttachment
      Properties:
        SecretId:
          Ref: PostgresSecret
        RotationLambdaARN: !GetAtt RotatorLambdaFunction.Arn
        RotationRules:
          AutomaticallyAfterDays: 30

    LambdaInvokePermission:
      Type: AWS::Lambda::Permission
      DependsOn: RotatorLambdaFunction
      Properties:
        Action: lambda:InvokeFunction
        FunctionName: !GetAtt RotatorLambdaFunction.Arn
        Principal: 'secretsmanager.amazonaws.com'

  Outputs:
    PostgresAuroraV2Arn:
      Value: !Sub 'arn:aws:rds:${AWS::Region}:${AWS::AccountId}:cluster:${PostgresAuroraV2}'
    PostgresVMScriptsBucket:
      Condition: IsDevValProd
      Value: !Ref PostgresVMScriptsBucket
