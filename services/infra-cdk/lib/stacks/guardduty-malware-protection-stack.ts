import { BaseStack, BaseStackProps } from '@constructs/base';
import { BaseLambdaFunction } from '@constructs/lambda';
import { Construct } from 'constructs';
import * as guardduty from 'aws-cdk-lib/aws-guardduty';
import * as iam from 'aws-cdk-lib/aws-iam';
import * as s3 from 'aws-cdk-lib/aws-s3';
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as events from 'aws-cdk-lib/aws-events';
import * as targets from 'aws-cdk-lib/aws-events-targets';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as sns from 'aws-cdk-lib/aws-sns';
import * as snsSubscriptions from 'aws-cdk-lib/aws-sns-subscriptions';
import * as sqs from 'aws-cdk-lib/aws-sqs';
import * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch';
import * as cloudwatchActions from 'aws-cdk-lib/aws-cloudwatch-actions';
import { Duration, RemovalPolicy, CfnOutput } from 'aws-cdk-lib';
import { SERVICES, PROJECT_PREFIX } from '@config/constants';
// import { NagSuppressions } from 'cdk-nag';

export interface GuardDutyMalwareProtectionStackProps extends BaseStackProps {
  uploadsBucket: s3.IBucket;
  qaBucket: s3.IBucket;
  alertEmail?: string;
  enableClamAvCompatibility?: boolean; // Enable ClamAV tag compatibility mode
  enableRescanCapability?: boolean; // Enable rescan functionality
  vpc?: ec2.IVpc; // VPC for Lambda functions
  lambdaSecurityGroup?: ec2.ISecurityGroup; // Security group for Lambda functions
}

/**
 * GuardDuty Malware Protection stack for S3 virus scanning
 * This stack provides a managed, serverless alternative to ClamAV
 */
export class GuardDutyMalwareProtectionStack extends BaseStack {
  public detector?: guardduty.CfnDetector;
  public malwareProtectionRole: iam.IRole;
  public uploadsMalwareProtectionPlan?: guardduty.CfnMalwareProtectionPlan;
  public qaMalwareProtectionPlan?: guardduty.CfnMalwareProtectionPlan;
  public scanResultProcessor?: BaseLambdaFunction;
  public rescanHandler?: BaseLambdaFunction;
  public comparisonMetrics?: BaseLambdaFunction;
  public rescanQueue?: sqs.IQueue;
  public alertTopic?: sns.ITopic;
  private readonly uploadsBucket: s3.IBucket;
  private readonly qaBucket: s3.IBucket;
  private readonly alertEmail?: string;
  private readonly enableClamAvCompatibility: boolean;
  private readonly enableRescanCapability: boolean;
  private readonly vpc?: ec2.IVpc;
  private readonly lambdaSecurityGroup?: ec2.ISecurityGroup;

  constructor(scope: Construct, id: string, props: GuardDutyMalwareProtectionStackProps) {
    super(scope, id, {
      ...props,
      description: 'GuardDuty Malware Protection stack for Managed Care Review - Serverless virus scanning'
    });
    
    // Store required props
    this.uploadsBucket = props.uploadsBucket;
    this.qaBucket = props.qaBucket;
    this.alertEmail = props.alertEmail;
    this.enableClamAvCompatibility = props.enableClamAvCompatibility ?? true;
    this.enableRescanCapability = props.enableRescanCapability ?? true;
    this.vpc = props.vpc;
    this.lambdaSecurityGroup = props.lambdaSecurityGroup;
    
    this.defineResources();
  }

  protected defineResources(): void {

    // Only enable GuardDuty for non-ephemeral environments
    if (this.stage !== 'ephemeral') {
      // Create GuardDuty detector if not already enabled
      this.createGuardDutyDetector();

      // Create IAM role for Malware Protection
      this.createMalwareProtectionRole();

      // Create Malware Protection Plans
      this.createMalwareProtectionPlans();

      // Add bucket policies for virus scan enforcement
      this.addVirusScanBucketPolicies();

      // Create EventBridge integration
      this.createEventBridgeIntegration();

      // Create rescan capability if enabled
      if (this.enableRescanCapability) {
        this.createRescanCapability();
      }

      // Create comparison metrics for migration monitoring
      if (this.enableClamAvCompatibility) {
        this.createComparisonMetrics();
      }

      // Apply CDK Nag suppressions
      // this.applyCdkNagSuppressions();
    }
  }

  private createGuardDutyDetector(): void {
    // Check if detector already exists by attempting to create one
    // If it fails, it means it already exists
    try {
      this.detector = new guardduty.CfnDetector(this, 'GuardDutyDetector', {
        enable: true,
        findingPublishingFrequency: 'FIFTEEN_MINUTES',
        dataSources: {
          s3Logs: {
            enable: true
          }
        }
      });

      new CfnOutput(this, 'GuardDutyDetectorId', {
        value: this.detector.ref,
        description: 'GuardDuty Detector ID',
        exportName: this.exportName('GuardDutyDetectorId')
      });
    } catch (error) {
      // Detector likely already exists, which is fine
      console.log('GuardDuty detector may already exist, continuing...');
    }
  }

  private createMalwareProtectionRole(): void {
    this.malwareProtectionRole = new iam.Role(this, 'MalwareProtectionRole', {
      roleName: `${PROJECT_PREFIX}-guardduty-malware-protection-${this.stage}`,
      assumedBy: new iam.ServicePrincipal('malware-protection.guardduty.amazonaws.com'),
      description: 'Role for GuardDuty Malware Protection to scan S3 objects',
      inlinePolicies: {
        S3ScanPolicy: new iam.PolicyDocument({
          statements: [
            // Read permissions for scanning
            new iam.PolicyStatement({
              effect: iam.Effect.ALLOW,
              actions: [
                's3:GetObject',
                's3:GetObjectVersion',
                's3:GetObjectAttributes',
                's3:ListBucket'
              ],
              resources: [
                this.uploadsBucket.bucketArn,
                `${this.uploadsBucket.bucketArn}/*`,
                this.qaBucket.bucketArn,
                `${this.qaBucket.bucketArn}/*`
              ]
            }),
            // Tagging permissions for scan results
            new iam.PolicyStatement({
              effect: iam.Effect.ALLOW,
              actions: [
                's3:PutObjectTagging',
                's3:PutObjectVersionTagging',
                's3:GetObjectTagging',
                's3:GetObjectVersionTagging'
              ],
              resources: [
                `${this.uploadsBucket.bucketArn}/*`,
                `${this.qaBucket.bucketArn}/*`
              ]
            }),
            // KMS permissions for encrypted buckets
            new iam.PolicyStatement({
              effect: iam.Effect.ALLOW,
              actions: [
                'kms:Decrypt',
                'kms:DescribeKey'
              ],
              resources: ['*'],
              conditions: {
                StringEquals: {
                  'kms:ViaService': [
                    `s3.${this.region}.amazonaws.com`
                  ]
                }
              }
            })
          ]
        })
      }
    });
  }

  private createMalwareProtectionPlans(): void {
    // Create Malware Protection Plan for Uploads bucket
    this.uploadsMalwareProtectionPlan = new guardduty.CfnMalwareProtectionPlan(this, 'UploadsMalwareProtectionPlan', {
      role: this.malwareProtectionRole.roleArn,
      protectedResource: {
        s3Bucket: {
          bucketName: this.uploadsBucket.bucketName
          // No objectPrefixes - scan all objects
        }
      },
      actions: {
        tagging: {
          status: 'ENABLED' // Enable automatic tagging with scan results
        }
      },
      tags: [
        { key: 'Environment', value: this.stage },
        { key: 'Purpose', value: 'MalwareScanning' },
        { key: 'ManagedBy', value: 'CDK' },
        { key: 'Service', value: SERVICES.UPLOADS }
      ]
    });

    // Create Malware Protection Plan for QA bucket
    this.qaMalwareProtectionPlan = new guardduty.CfnMalwareProtectionPlan(this, 'QaMalwareProtectionPlan', {
      role: this.malwareProtectionRole.roleArn,
      protectedResource: {
        s3Bucket: {
          bucketName: this.qaBucket.bucketName,
          // Optional: Scan only specific prefixes
          objectPrefixes: ['documents/', 'uploads/', 'submissions/']
        }
      },
      actions: {
        tagging: {
          status: 'ENABLED'
        }
      },
      tags: [
        { key: 'Environment', value: this.stage },
        { key: 'Purpose', value: 'MalwareScanning' },
        { key: 'ManagedBy', value: 'CDK' },
        { key: 'Service', value: SERVICES.UPLOADS }
      ]
    });

    // Create outputs
    new CfnOutput(this, 'UploadsMalwareProtectionPlanId', {
      value: this.uploadsMalwareProtectionPlan.ref,
      description: 'Uploads bucket Malware Protection Plan ID',
      exportName: this.exportName('UploadsMalwareProtectionPlanId')
    });

    new CfnOutput(this, 'QaMalwareProtectionPlanId', {
      value: this.qaMalwareProtectionPlan.ref,
      description: 'QA bucket Malware Protection Plan ID',
      exportName: this.exportName('QaMalwareProtectionPlanId')
    });
  }

  private addVirusScanBucketPolicies(): void {
    // Define allowed file extensions (matching serverless implementation)
    const allowedFileExtensions = [
      '*.csv', '*.doc', '*.docx', '*.pdf', '*.txt', 
      '*.xls', '*.xlsx', '*.zip', '*.xlsm', '*.xltm', '*.xlam'
    ];

    // Get Lambda execution role ARN for exception
    const lambdaRoleArn = this.scanResultProcessor?.role?.roleArn || '*';

    // Add bucket policy to uploads bucket - Deny GetObject unless file is clean
    const uploadsBucketPolicy = new iam.PolicyStatement({
      sid: 'DenyUnscannedFileAccess',
      effect: iam.Effect.DENY,
      principals: [new iam.AnyPrincipal()],
      actions: ['s3:GetObject'],
      resources: [`${this.uploadsBucket.bucketArn}/*`]
    });

    // Add conditions - must match serverless implementation logic
    uploadsBucketPolicy.addCondition('StringNotEquals', {
      's3:ExistingObjectTag/virusScanStatus': 'CLEAN'
    });
    uploadsBucketPolicy.addCondition('StringNotEquals', {
      's3:ExistingObjectTag/contentsPreviouslyScanned': 'TRUE'
    });
    uploadsBucketPolicy.addCondition('StringNotEquals', {
      'aws:PrincipalArn': lambdaRoleArn
    });

    // Add file type restriction policy
    const fileTypePolicy = new iam.PolicyStatement({
      sid: 'DenyNonAllowedFileTypes',
      effect: iam.Effect.DENY,
      principals: [new iam.AnyPrincipal()],
      actions: ['s3:PutObject'],
      notResources: allowedFileExtensions.map(ext => `${this.uploadsBucket.bucketArn}/${ext}`)
    });

    // Add SSL enforcement policy
    const sslPolicy = new iam.PolicyStatement({
      sid: 'DenyUnencryptedConnections',
      effect: iam.Effect.DENY,
      principals: [new iam.AnyPrincipal()],
      actions: ['s3:*'],
      resources: [
        this.uploadsBucket.bucketArn,
        `${this.uploadsBucket.bucketArn}/*`
      ],
      conditions: {
        Bool: {
          'aws:SecureTransport': 'false'
        }
      }
    });

    // Apply policies to uploads bucket
    this.uploadsBucket.addToResourcePolicy(uploadsBucketPolicy);
    this.uploadsBucket.addToResourcePolicy(fileTypePolicy);
    this.uploadsBucket.addToResourcePolicy(sslPolicy);

    // Apply same policies to QA bucket
    const qaBucketPolicy = new iam.PolicyStatement({
      sid: 'DenyUnscannedFileAccessQA',
      effect: iam.Effect.DENY,
      principals: [new iam.AnyPrincipal()],
      actions: ['s3:GetObject'],
      resources: [`${this.qaBucket.bucketArn}/*`]
    });

    qaBucketPolicy.addCondition('StringNotEquals', {
      's3:ExistingObjectTag/virusScanStatus': 'CLEAN'
    });
    qaBucketPolicy.addCondition('StringNotEquals', {
      's3:ExistingObjectTag/contentsPreviouslyScanned': 'TRUE'
    });
    qaBucketPolicy.addCondition('StringNotEquals', {
      'aws:PrincipalArn': lambdaRoleArn
    });

    const qaFileTypePolicy = new iam.PolicyStatement({
      sid: 'DenyNonAllowedFileTypesQA',
      effect: iam.Effect.DENY,
      principals: [new iam.AnyPrincipal()],
      actions: ['s3:PutObject'],
      notResources: allowedFileExtensions.map(ext => `${this.qaBucket.bucketArn}/${ext}`)
    });

    const qaSslPolicy = new iam.PolicyStatement({
      sid: 'DenyUnencryptedConnectionsQA',
      effect: iam.Effect.DENY,
      principals: [new iam.AnyPrincipal()],
      actions: ['s3:*'],
      resources: [
        this.qaBucket.bucketArn,
        `${this.qaBucket.bucketArn}/*`
      ],
      conditions: {
        Bool: {
          'aws:SecureTransport': 'false'
        }
      }
    });

    this.qaBucket.addToResourcePolicy(qaBucketPolicy);
    this.qaBucket.addToResourcePolicy(qaFileTypePolicy);
    this.qaBucket.addToResourcePolicy(qaSslPolicy);
  }

  private createEventBridgeIntegration(): void {
    // Create SNS topic for alerts
    this.alertTopic = new sns.Topic(this, 'MalwareAlertTopic', {
      topicName: `${PROJECT_PREFIX}-guardduty-malware-alerts-${this.stage}`,
      displayName: 'GuardDuty Malware Alerts'
    });

    // Subscribe email if provided
    if (this.alertEmail) {
      this.alertTopic.addSubscription(
        new snsSubscriptions.EmailSubscription(this.alertEmail)
      );
    }

    // Create Lambda function to process scan results
    this.scanResultProcessor = new BaseLambdaFunction(this, 'ScanResultProcessor', {
      functionName: 'guardduty-scan-processor',
      serviceName: 'infra-cdk',
      handler: 'lambdas/uploads/guardDutyScanProcessor.handler',
      stage: this.stage,
      lambdaConfig: {
        ...this.stageConfig.lambda,
        timeout: Duration.seconds(300), // Match ClamAV timeout
        memorySize: 1024 // Sufficient for tag processing
      },
      environment: {
        stage: this.stage,
        STAGE: this.stage,
        ALERT_TOPIC_ARN: this.alertTopic.topicArn,
        UPLOADS_BUCKET: this.uploadsBucket.bucketName,
        QA_BUCKET: this.qaBucket.bucketName,
        ENABLE_CLAMAV_COMPATIBILITY: String(this.enableClamAvCompatibility !== false),
        MAX_FILE_SIZE: '314572800', // Match ClamAV max file size
        AWS_LAMBDA_EXEC_WRAPPER: '/opt/otel-handler',
        OPENTELEMETRY_COLLECTOR_CONFIG_FILE: '/var/task/collector.yml',
        VITE_APP_OTEL_COLLECTOR_URL: process.env.VITE_APP_OTEL_COLLECTOR_URL || ''
      },
      vpc: this.vpc,
      vpcSubnets: this.vpc ? { subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS } : undefined,
      securityGroups: this.lambdaSecurityGroup ? [this.lambdaSecurityGroup] : undefined,
      layers: [
        lambda.LayerVersion.fromLayerVersionArn(
          this,
          'OtelLayerScanProcessor',
          'arn:aws:lambda:us-east-1:901920570463:layer:aws-otel-nodejs-amd64-ver-1-18-1:4'
        )
      ]
    });

    // Grant permissions
    this.uploadsBucket.grantRead(this.scanResultProcessor.function);
    this.qaBucket.grantRead(this.scanResultProcessor.function);
    this.alertTopic.grantPublish(this.scanResultProcessor.function);

    // Grant tagging permissions to scan result processor
    this.scanResultProcessor.function.addToRolePolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        's3:GetObjectTagging',
        's3:PutObjectTagging',
        's3:GetObjectVersionTagging',
        's3:PutObjectVersionTagging'
      ],
      resources: [
        `${this.uploadsBucket.bucketArn}/*`,
        `${this.qaBucket.bucketArn}/*`
      ]
    }));

    // Create EventBridge rule for all scan results
    const scanCompleteRule = new events.Rule(this, 'ScanCompleteRule', {
      ruleName: `${PROJECT_PREFIX}-guardduty-scan-complete-${this.stage}`,
      description: 'Trigger on GuardDuty malware scan completion',
      eventPattern: {
        source: ['aws.guardduty'],
        detailType: ['GuardDuty Malware Protection Object Scan Result'],
        detail: {
          scanResult: ['CLEAN', 'THREATS_FOUND', 'UNSUPPORTED', 'FAILED']
        }
      }
    });

    scanCompleteRule.addTarget(new targets.LambdaFunction(this.scanResultProcessor.function));

    // Create rule for threats only
    const threatDetectedRule = new events.Rule(this, 'ThreatDetectedRule', {
      ruleName: `${PROJECT_PREFIX}-guardduty-threat-detected-${this.stage}`,
      description: 'Trigger only when threats are found',
      eventPattern: {
        source: ['aws.guardduty'],
        detailType: ['GuardDuty Malware Protection Object Scan Result'],
        detail: {
          scanResult: ['THREATS_FOUND']
        }
      }
    });

    // Send threat alerts to SNS
    threatDetectedRule.addTarget(new targets.SnsTopic(this.alertTopic));
  }

  private createRescanCapability(): void {
    // Create SQS queue for rescan requests
    this.rescanQueue = new sqs.Queue(this, 'RescanQueue', {
      queueName: `${PROJECT_PREFIX}-guardduty-rescan-${this.stage}`,
      visibilityTimeout: Duration.minutes(5),
      retentionPeriod: Duration.days(7),
      encryption: sqs.QueueEncryption.KMS_MANAGED
    });

    // Create Lambda function for handling rescans
    this.rescanHandler = new BaseLambdaFunction(this, 'RescanHandler', {
      functionName: 'guardduty-rescan-handler',
      serviceName: 'infra-cdk',
      handler: 'lambdas/uploads/guardDutyRescanHandler.handler',
      stage: this.stage,
      lambdaConfig: {
        ...this.stageConfig.lambda,
        timeout: Duration.minutes(5),
        memorySize: 1024,
        reservedConcurrentExecutions: 10 // Limit concurrent rescans
      },
      environment: {
        stage: this.stage,
        STAGE: this.stage,
        RESCAN_NOTIFICATION_QUEUE_URL: this.rescanQueue.queueUrl,
        AUDIT_BUCKET_NAME: this.uploadsBucket.bucketName,
        RESCAN_WORKER_LAMBDA_NAME: `${SERVICES.UPLOADS}-${this.stage}-rescan-worker`,
        MAX_FILE_SIZE: '314572800',
        AWS_LAMBDA_EXEC_WRAPPER: '/opt/otel-handler',
        OPENTELEMETRY_COLLECTOR_CONFIG_FILE: '/var/task/collector.yml',
        VITE_APP_OTEL_COLLECTOR_URL: process.env.VITE_APP_OTEL_COLLECTOR_URL || ''
      },
      vpc: this.vpc,
      vpcSubnets: this.vpc ? { subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS } : undefined,
      securityGroups: this.lambdaSecurityGroup ? [this.lambdaSecurityGroup] : undefined,
      layers: [
        lambda.LayerVersion.fromLayerVersionArn(
          this,
          'OtelLayerRescanHandler',
          'arn:aws:lambda:us-east-1:901920570463:layer:aws-otel-nodejs-amd64-ver-1-18-1:4'
        )
      ]
    });

    // Create rescan worker Lambda (for parallel processing)
    const rescanWorker = new BaseLambdaFunction(this, 'RescanWorker', {
      functionName: 'rescan-worker',
      serviceName: 'infra-cdk',
      handler: 'lambdas/uploads/guardDutyRescanWorker.handler',
      stage: this.stage,
      lambdaConfig: {
        ...this.stageConfig.lambda,
        timeout: Duration.minutes(5),
        memorySize: 2048,
      },
      environment: {
        stage: this.stage,
        STAGE: this.stage,
        AUDIT_BUCKET_NAME: this.uploadsBucket.bucketName,
        MAX_FILE_SIZE: '314572800',
        AWS_LAMBDA_EXEC_WRAPPER: '/opt/otel-handler',
        OPENTELEMETRY_COLLECTOR_CONFIG_FILE: '/var/task/collector.yml',
        VITE_APP_OTEL_COLLECTOR_URL: process.env.VITE_APP_OTEL_COLLECTOR_URL || ''
      },
      vpc: this.vpc,
      vpcSubnets: this.vpc ? { subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS } : undefined,
      securityGroups: this.lambdaSecurityGroup ? [this.lambdaSecurityGroup] : undefined,
      layers: [
        lambda.LayerVersion.fromLayerVersionArn(
          this,
          'OtelLayerRescanWorker',
          'arn:aws:lambda:us-east-1:901920570463:layer:aws-otel-nodejs-amd64-ver-1-18-1:4'
        )
      ]
    });

    // Grant permissions
    this.uploadsBucket.grantReadWrite(this.rescanHandler.function);
    this.qaBucket.grantReadWrite(this.rescanHandler.function);
    this.uploadsBucket.grantReadWrite(rescanWorker.function);
    this.qaBucket.grantReadWrite(rescanWorker.function);
    
    // Grant tagging permissions
    this.rescanHandler.function.addToRolePolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        's3:GetObjectTagging',
        's3:PutObjectTagging',
        's3:GetObjectVersionTagging',
        's3:PutObjectVersionTagging'
      ],
      resources: [
        `${this.uploadsBucket.bucketArn}/*`,
        `${this.qaBucket.bucketArn}/*`
      ]
    }));

    rescanWorker.function.addToRolePolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: [
        's3:GetObjectTagging',
        's3:PutObjectTagging',
        's3:GetObjectVersionTagging',
        's3:PutObjectVersionTagging'
      ],
      resources: [
        `${this.uploadsBucket.bucketArn}/*`,
        `${this.qaBucket.bucketArn}/*`
      ]
    }));

    // Grant rescan handler permission to invoke worker
    rescanWorker.grantInvoke(this.rescanHandler.function);

    // Grant queue permissions
    this.rescanQueue.grantSendMessages(this.rescanHandler.function);
    this.rescanQueue.grantConsumeMessages(this.rescanHandler.function);

    // Create EventBridge rule for failed scans that might need rescan
    const failedScanRule = new events.Rule(this, 'FailedScanRule', {
      ruleName: `${PROJECT_PREFIX}-guardduty-failed-scan-${this.stage}`,
      description: 'Trigger on failed GuardDuty scans for potential rescan',
      eventPattern: {
        source: ['aws.guardduty'],
        detailType: ['GuardDuty Malware Protection Object Scan Result'],
        detail: {
          scanResult: ['FAILED', 'ACCESS_DENIED']
        }
      }
    });

    // Optionally trigger rescan handler for failed scans
    failedScanRule.addTarget(new targets.LambdaFunction(this.rescanHandler.function, {
      retryAttempts: 2
    }));


    // Export rescan queue URL for use by other services
    new CfnOutput(this, 'RescanQueueUrl', {
      value: this.rescanQueue.queueUrl,
      description: 'URL for GuardDuty rescan request queue',
      exportName: this.exportName('GuardDutyRescanQueueUrl')
    });
  }

  private createComparisonMetrics(): void {
    // Create Lambda function for comparison metrics
    this.comparisonMetrics = new BaseLambdaFunction(this, 'ComparisonMetrics', {
      functionName: 'virus-scan-comparison',
      serviceName: 'infra-cdk',
      handler: 'lambdas/uploads/virusScanComparisonMetrics.handler',
      stage: this.stage,
      lambdaConfig: {
        ...this.stageConfig.lambda,
        timeout: Duration.minutes(5),
        memorySize: 512
      },
      environment: {
        stage: this.stage,
        STAGE: this.stage,
        MONITORED_BUCKETS: `${this.uploadsBucket.bucketName},${this.qaBucket.bucketName}`,
        METRICS_NAMESPACE: `${PROJECT_PREFIX}/VirusScanComparison`,
        ALERT_TOPIC_ARN: this.alertTopic?.topicArn || '',
        AWS_LAMBDA_EXEC_WRAPPER: '/opt/otel-handler',
        OPENTELEMETRY_COLLECTOR_CONFIG_FILE: '/var/task/collector.yml',
        VITE_APP_OTEL_COLLECTOR_URL: process.env.VITE_APP_OTEL_COLLECTOR_URL || ''
      },
      vpc: this.vpc,
      vpcSubnets: this.vpc ? { subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS } : undefined,
      securityGroups: this.lambdaSecurityGroup ? [this.lambdaSecurityGroup] : undefined,
      layers: [
        lambda.LayerVersion.fromLayerVersionArn(
          this,
          'OtelLayerComparison',
          'arn:aws:lambda:us-east-1:901920570463:layer:aws-otel-nodejs-amd64-ver-1-18-1:4'
        )
      ]
    });

    // Grant permissions
    this.uploadsBucket.grantRead(this.comparisonMetrics.function);
    this.qaBucket.grantRead(this.comparisonMetrics.function);
    
    // Grant tagging permissions
    this.comparisonMetrics.function.addToRolePolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: ['s3:GetObjectTagging'],
      resources: [
        `${this.uploadsBucket.bucketArn}/*`,
        `${this.qaBucket.bucketArn}/*`
      ]
    }));

    // Grant CloudWatch metrics permissions
    this.comparisonMetrics.function.addToRolePolicy(new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      actions: ['cloudwatch:PutMetricData'],
      resources: ['*']
    }));

    if (this.alertTopic) {
      this.alertTopic.grantPublish(this.comparisonMetrics.function);
    }

    // Schedule the comparison to run every hour
    const scheduleRule = new events.Rule(this, 'ComparisonSchedule', {
      ruleName: `${PROJECT_PREFIX}-scan-comparison-${this.stage}`,
      description: 'Hourly comparison of virus scan results',
      schedule: events.Schedule.rate(Duration.hours(1))
    });

    scheduleRule.addTarget(new targets.LambdaFunction(this.comparisonMetrics.function));

  }


  /**
   * Apply CDK Nag suppressions for this stack
   */
  private applyCdkNagSuppressions(): void {
    // CDK Nag suppressions temporarily disabled
  }
}
